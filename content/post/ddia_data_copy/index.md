---
# Documentation: https://wowchemy.com/docs/managing-content/

title: "[DDIA]数据复制"
subtitle: ""
summary: "数据复制模型：主从复制，多主复制，无主复制。以及各种模型下的问题和解决方案等。"
authors: []
tags: []
categories: []
date: 2023-07-23T23:09:59+08:00
lastmod: 2023-07-23T23:09:59+08:00
featured: false
draft: false

# Featured image
# To use, add an image named `featured.jpg/png` to your page's folder.
# Focal points: Smart, Center, TopLeft, Top, TopRight, Left, Right, BottomLeft, Bottom, BottomRight.
image:
  caption: ""
  focal_point: ""
  preview_only: false

# Projects (optional).
#   Associate this post with one or more of your projects.
#   Simply enter your project's folder or file name without extension.
#   E.g. `projects = ["internal-project"]` references `content/project/deep-learning/index.md`.
#   Otherwise, set `projects = []`.
projects: []
---
# 数据复制
## 数据复制的目的
- 高可用：一个节点挂掉时，整个系统还有其他节点可以工作。
- 低延迟：使数据在地理位置上更靠近用户，降低网络延迟。
- 高吞吐：多个节点可访问，提高系统整体吞吐量。

## 主从复制
主从复制指，系统有一个主节点，多个从节点，写请求只发送给主节点，主写入本地后，发送日志给从节点，从节点进行更新。主节点和从节点都可以接收读请求。
主从复制需要考虑的问题：
- 调节同步和异步复制的节点比例，这会影响系统的吞吐，延迟，数据更新比例等。
- 从节点新增/恢复。从本地或向主节点请求某时刻的日志snapshot，执行后继续从主节点同步后续日志。
- 主节点挂掉：确认主节点挂掉的条件，leader选举，重新配置主节点。

日志复制：
- 基于语句：将主节点执行的语句发送到从节点。
- 基于预写日志（WAL）：对于追加写到日志的，可以将日志发送给从节点。*缺点：日志描述的数据非常底层。（不理解）*
- 基于行的逻辑日志：将复制和存储方式分离。复制日志是一种逻辑日志，并不真正实现存储。MySQL的二进制binlog是采用这种方式。

### 复制滞后可能出现的问题
**读自己的写不一致：**
- 对于客户端有权限修改的内容，读主节点，否则读从节点。但对于大家都有权限修改的内容，就失效了。
- 客户端记录写的时间，读的时间小于1min，读主节点，否则读从节点。这对阈值的设置要求比较高。
- 客户端维护最近写的时间戳，附带在读请求。当节点包含该时间戳的更新，才返回结果。但理论上不同节点的时间无法完全一致。

**单调读：**

当前一次读的内容新于后一次读，比如第一次看到数据，再刷新数据消失。可能是由于第一次读的节点数据更新了，第二次读的节点数据未更新。

单调读一致性是指，用户多次读取，不会看到版本回滚的现象。

实现单调读的方法：确保用户每次都读一个节点，可以对用户id进行hash，路由到节点。

**前缀一致读：**
对于一系列按照顺序发生的写请求，读取时也需要按照写入顺序读取。


## 多主复制
每个主节点都可以接受写请求，同时是其他主节点的从节点。多主节点的结构**适用于多数据中心**的场景。多数据中心一般在不同region，为了靠近用户。但如果只有一个主节点，在一个数据中心，则失去了按region分配的意义。

**数据中心内主从模型，所有数据中心构成多主模型。**


多主复制的优势：
- 多主提高整个系统的吞吐
- 更高容错，一个主节点挂掉，数据中心内再选举一个主节点，不需要垮数据中心选举，不会造成网络负担大。
- 多主节点之间采用异步复制，网络失效影响较小。

多主复制的问题：不同数据中心同时修改相同的数据，需要处理写冲突。解决方案：
- 避免冲突：在应用层避免写入冲突。例如用户更新自己的数据，写请求只路由到特定的数据中心。但如果数据中心故障，或者用户去其他位置，则需要解决数据中心之间的冲突。
- 收敛到一致状态：比如每个用户提供写入时间戳，按顺序写入。

自动冲突解决：规则可能变得很复杂，有一些从数据结构和算法层面解决冲突的方案：
- 无冲突的复制数据类型（CRDT），可以由多个用户同时编辑，以内置方法解决冲突。
- 可合并的持久数据结构：像Git一样跟踪版本，提出*三向合并功能*。
- 操作转换：是Etherpad和Google Docs的冲突解决算法。

## 无主复制
没有主节点，去中心复制，每个节点都可以接受写请求。Amazon内部的Dynamo掀起一阵无主复制的热潮。

无主节点系统的：
- 读修复：client的读同时请求到多个节点，对比version，将version最新的作为结果。
- 反熵：background进程扫描节点之间副本的差异，并复制。

Q: 怎么判断无主系统处理读写请求时，是最新状态？

假设有n个节点，写入需要w个节点确认，读取需要r个节点确认，则w+r>n，读取的节点中一定包含最新值，w和r有overlap。将w和r成为法定票数写和法定票数读，用于判断读和写是否有效。

Q: 如果此时系统因为一些原因，例如网络问题，导致无法满足w和r，怎么处理？

可以采用sloppy quorum，允许w个写入和r个读，但可以不在指定的n个节点。这里应该是集群比较大，n不是全部节点数，有备用节点的情况。等问题修复好，再同步到n个节点。但在sloppy quorum下，即便满足w+r>n，也不保证读到最新值。



